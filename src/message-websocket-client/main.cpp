#pragma comment(lib, "runtimeobject.lib")

// See https://learn.microsoft.com/en-us/windows/uwp/networking/websockets
#include <winrt/windows.foundation.h>
#include <winrt/windows.foundation.collections.h>
#include <winrt/windows.networking.sockets.h>
#include <winrt/windows.storage.h>
#include <winrt/windows.storage.streams.h>
#include <chrono> // https://github.com/microsoft/STL/issues/3992
#include <semaphore>
#include <iostream>
#include <format>

//import <iostream>;
//import <chrono>;
//import <semaphore>;
//import <format>;

int main() try
{
    namespace Networking = winrt::Windows::Networking;
    namespace Sockets = winrt::Windows::Networking::Sockets;
    namespace Streams = winrt::Windows::Storage::Streams;

    std::counting_semaphore messages{ 0 };

    Sockets::MessageWebSocket mws;
    // This lambda gets invoked whenever we received a message.
    // You should technically also subscribe to the Closed() event.
    mws.MessageReceived(
        [&messages](
            const Sockets::MessageWebSocket& /* sender */,
            const Sockets::MessageWebSocketMessageReceivedEventArgs& args
        )
        {
            try
            {
                Streams::DataReader dr = args.GetDataReader();
                std::wstring message{ dr.ReadString(dr.UnconsumedBufferLength()) };
                std::wcout << std::format(
                    L"Received websocket message: {}\n",
                    message
                );
                messages.release();
            }
            catch (const winrt::hresult_error& ex)
            {
                std::wcerr << std::format(
                    L"Failed reading websocket message due to hresult: {}\n",
                    std::wstring{ ex.message() }
                );
            }
            catch (const std::exception& ex)
            {
                // These can be generated by the semaphore
                std::wcerr << std::format(
                    "Failed reading websocket message due to std::exception: {}\n",
                    ex.what()
                ).c_str();
            }
        }
    );
    
    // You would typically co_await this, but the standard defines that main
    // cannot be a coroutine, so we can't do that here.
    auto operation = mws.ConnectAsync(
        // echo.websocket.org is now gone, but we can use this.
        // See https://www.lob.com/blog/websocket-org-is-down-here-is-an-alternative
        winrt::Windows::Foundation::Uri(L"wss://echo.websocket.events/.ws")
    );
    operation.get();

    // Output a message to be received back.
    Streams::DataWriter dw(mws.OutputStream());
    dw.WriteString(L"Hello, world!");
    dw.StoreAsync().get();
    dw.FlushAsync().get();

    // We expect the initial banner message and then actual echo.
    if (!messages.try_acquire_for(std::chrono::seconds{ 5 }))
    {
        std::wcerr << L"Timed out waiting for initial message.\n";
        return 1;
    }
    if (!messages.try_acquire_for(std::chrono::seconds(5)))
    {
        std::wcerr << L"Timed out waiting for echo.\n";
        return 1;
    }

    std::wcout << L"Successfully received all expected messages.\n";
    return 0;
}
catch (const winrt::hresult_error& ex)
{
    std::wcerr << std::format(
        L"winrt::hresult_error: {}\n", 
        std::wstring{ ex.message() }
    );
    return 1;
}
catch (const std::exception& ex)
{
    // These can be generated by the semaphore
    std::wcerr << std::format(
        "std::exception: {}\n",
        ex.what()
    ).c_str();
    return 1;
}
